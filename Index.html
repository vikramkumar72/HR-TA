<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resume ↔ Job Description Matcher — Demo</title>
  <style>
    :root{
      --bg:#f6f8fb; --card:#ffffff; --muted:#687082;
      --accent:#2b7cff; --good:#1db954; --warn:#ffb020; --bad:#ff5252;
      --radius:12px;
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #0b1220;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);}

    .container{
      max-width:1200px;margin:28px auto;padding:20px;
      display:grid;grid-template-columns:1fr 420px;gap:18px;
    }

    .card{
      background:var(--card);border-radius:var(--radius);padding:18px;
      box-shadow: 0 6px 18px rgba(13,21,38,0.06);
    }

    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    header h1{font-size:18px;margin:0}
    header p{margin:0;color:var(--muted);font-size:13px}

    /* Left column: inputs */
    .input-area{display:flex;flex-direction:column;gap:12px}
    .dropzone{
      border:2px dashed #e3e9f2;border-radius:10px;padding:14px;display:flex;gap:12px;
      align-items:center;cursor:pointer;background:linear-gradient(180deg, rgba(255,255,255,0.6), transparent);
    }
    .dropzone.dragover{border-color:var(--accent);box-shadow:inset 0 0 0 3px rgba(43,124,255,0.06)}
    .dropzone small{color:var(--muted);display:block}

    .meta{font-size:13px;color:var(--muted);margin-top:6px}

    label{font-weight:600;font-size:13px;color:#0b1220;display:block;margin-bottom:6px}

    .row{display:flex;gap:12px;align-items:center}
    .btn{background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .btn.secondary{background:#eef4ff;color:var(--accent)}
    .file-info{font-size:13px;color:var(--muted)}

    textarea{width:100%;min-height:140px;padding:12px;border-radius:8px;border:1px solid #e6ebf5;background:#fbfdff;margin-top:6px;resize:vertical}
    .small{font-size:12px;color:var(--muted)}

    /* Right column: results */
    .results{display:flex;flex-direction:column;gap:12px}
    .score-badge{display:flex;align-items:center;gap:12px}
    .badge{
      width:96px;height:96px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;
      font-weight:700;font-size:22px;
      box-shadow: 0 6px 18px rgba(11,18,32,0.05);
    }
    .progress{height:12px;border-radius:999px;background:#eef2f7;width:100%;overflow:hidden}
    .progress > i{height:100%;display:block;background:var(--accent);width:0}

    .match-lists{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .list{padding:12px;border-radius:10px;background:#fbfdff}

    /* preview area */
    .preview{padding:12px;border-radius:8px;min-height:160px;border:1px solid #e6ebf5;background:#fff}
    .preview .highlight{background:rgba(43,124,255,0.12);padding:0 4px;border-radius:4px;cursor:pointer}
    .preview .missing{background:rgba(255,82,82,0.08);border-bottom:2px dotted rgba(255,82,82,0.25);}

    .legend{display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted)}
    .legend span{display:inline-flex;align-items:center;gap:6px}

    footer{margin-top:10px;font-size:13px;color:var(--muted)}

    /* responsive */
    @media (max-width:980px){
      .container{grid-template-columns:1fr; padding:12px}
      .results{order:2}
    }

    /* small helpers */
    .muted{color:var(--muted);font-size:13px}
    .chip{display:inline-block;padding:6px 8px;border-radius:999px;border:1px solid #e6ebf5;font-size:13px;background:#fff}
    .toggle{display:inline-flex;align-items:center;gap:8px}
    .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}
    /* badges colors */
    .badge.good{background:linear-gradient(180deg,#ecfff3,#fff);}
    .badge.warn{background:linear-gradient(180deg,#fff8ec,#fff);}
    .badge.bad{background:linear-gradient(180deg,#fff6f6,#fff);}
    .hint{font-size:12px;color:var(--muted)}
    .control-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <main class="container" role="main" aria-labelledby="appTitle">
    <div class="card" aria-label="Upload and inputs">
      <header>
        <div>
          <h1 id="appTitle">Resume ↔ Job Description Matcher</h1>
          <p>Upload a resume and paste or upload a job description. The app runs client-side validation and shows a match score with highlights.</p>
        </div>
      </header>

      <section class="input-area" aria-labelledby="inputsHeading">
        <div>
          <label for="resumeDrop">Resume (PDF, DOCX, TXT)</label>
          <div id="resumeDrop" class="dropzone" tabindex="0" role="button" aria-label="Resume upload dropzone">
            <div>
              <svg width="40" height="40" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M12 3v10" stroke="#2b7cff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 7l4-4 4 4" stroke="#2b7cff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M21 21H3" stroke="#c8d7ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <div style="flex:1">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div>
                  <div style="font-weight:600">Drop or select a resume</div>
                  <small>PDF, DOCX, or TXT — privacy: processed locally</small>
                </div>
                <div>
                  <button id="resumeSelectBtn" class="btn secondary" aria-controls="resumeFile">Choose file</button>
                </div>
              </div>
              <div id="resumeMeta" class="meta" aria-live="polite"></div>
            </div>
            <input id="resumeFile" type="file" accept=".pdf,.docx,.doc,.txt,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document" class="visually-hidden" />
          </div>
        </div>

        <div>
          <label for="jdUpload">Job description (paste or upload)</label>
          <textarea id="jdText" placeholder="Paste job description text here..." aria-label="Job description text"></textarea>
          <div class="row" style="margin-top:8px;">
            <input id="jdFile" type="file" accept=".txt,.docx,.doc,text/plain,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document" class="visually-hidden" />
            <button id="jdSelectBtn" class="btn secondary">Upload JD</button>
            <div class="small muted" id="jdMeta"></div>
          </div>
        </div>

        <div class="row" style="margin-top:6px;align-items:center">
          <div class="toggle">
            <label for="mode">Matching mode:</label>
            <select id="mode" aria-label="Matching mode">
              <option value="strict">Strict (exact)</option>
              <option value="lenient">Lenient (fuzzy)</option>
            </select>
          </div>
          <div style="margin-left:auto" class="control-row">
            <button id="analyzeBtn" class="btn">Analyze</button>
            <button id="exportBtn" class="btn secondary">Export feedback</button>
          </div>
        </div>

        <div class="hint">Note: This demo performs client-side parsing. For robust PDF/DOCX extraction enable the bundled libraries (pdf.js & mammoth) by keeping the scripts in the page.</div>
      </section>
    </div>

    <aside class="card results" aria-label="Results & preview">
      <div class="score-badge" aria-live="polite">
        <div>
          <div id="scoreBadge" class="badge bad" role="status" aria-label="Match score">—%</div>
        </div>
        <div style="flex:1">
          <div style="display:flex;align-items:center;justify-content:space-between">
            <div>
              <div style="font-weight:700;font-size:15px">Match score</div>
              <div id="scoreLabel" class="muted">No analysis yet</div>
            </div>
            <div style="text-align:right">
              <div class="chip" id="experienceSummary">—</div>
            </div>
          </div>
          <div style="margin-top:10px">
            <div class="progress" aria-hidden="true"><i id="progressFill"></i></div>
            <div style="display:flex;justify-content:space-between;margin-top:6px;font-size:12px;color:var(--muted)"><span id="skillCount">Skills: —</span><span id="keywordCount">Keywords: —</span></div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
        <div class="legend" aria-hidden="true">
          <span><svg width="12" height="12"><rect width="12" height="12" rx="2" fill="rgba(43,124,255,0.12)"/></svg>Matched</span>
          <span><svg width="12" height="12"><rect width="12" height="12" rx="2" fill="rgba(255,82,82,0.08)"/></svg>Missing</span>
        </div>
        <div class="small muted">Click a highlighted token to see details</div>
      </div>

      <div class="match-lists" aria-label="Match lists">
        <div class="list">
          <div style="font-weight:700;margin-bottom:6px">Top matched skills</div>
          <div id="matchedSkills" class="small muted">—</div>
        </div>
        <div class="list">
          <div style="font-weight:700;margin-bottom:6px">Missing / suggested skills</div>
          <div id="missingSkills" class="small muted">—</div>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
        <div>
          <div style="font-weight:700;margin-bottom:6px">Resume preview</div>
          <div id="resumePreview" class="preview" tabindex="0" aria-live="polite">No resume loaded</div>
        </div>
        <div>
          <div style="font-weight:700;margin-bottom:6px">Job description preview</div>
          <div id="jdPreview" class="preview" tabindex="0" aria-live="polite">No job description</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <div style="font-weight:700;margin-bottom:6px">Recommended edits</div>
        <div id="recommendations" class="small muted">No suggestions yet</div>
      </div>

      <footer>
        <div class="small muted">All parsing and analysis happen client-side in your browser by default. This is a demo; parsing accuracy for PDFs/DOCX depends on included libraries.</div>
      </footer>
    </aside>
  </main>

  <!-- Optional libraries for better extraction.
       Keep or remove the tags. If offline, they will fail silently and the demo will still work for TXT. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js" integrity="" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.20/mammoth.browser.min.js" integrity="" crossorigin="anonymous"></script>

  <script>
  // ---------- Utility functions ----------
  function elt(tag, props={}, ...children){
    const e = document.createElement(tag);
    Object.assign(e, props);
    for(const c of children) if(c!=null) e.append(c);
    return e;
  }

  function fmtBytes(n){
    if(n<1024) return n+' B';
    if(n<1024*1024) return (n/1024).toFixed(1)+' KB';
    return (n/(1024*1024)).toFixed(2)+' MB';
  }

  function escapeRegex(s){return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');}

  // Levenshtein distance for fuzzy matching (small implementation)
  function levenshtein(a,b){
    a = a.toLowerCase(); b = b.toLowerCase();
    const m = a.length, n = b.length;
    const dp = Array.from({length:m+1}, ()=> new Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i;
    for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        const cost = a[i-1]===b[j-1]?0:1;
        dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
      }
    }
    return dp[m][n];
  }

  function fuzzyMatch(a,b){
    // return true if a approximately equals b (reasonable threshold)
    const dist = levenshtein(a,b);
    const len = Math.max(a.length,b.length);
    if(len<=3) return dist===0; // short tokens require exact
    return (dist/len) <= 0.34; // allow up to ~34% difference
  }

  // basic text normalization
  function normalizeText(s){ return s.replace(/\s+/g,' ').trim(); }

  // detect "years experience" in a piece of text
  function detectYears(text){
    const years = [];
    const re1 = /(\d{1,2})(?:\+)?\s*(?:years?|yrs?)/ig;
    let m;
    while((m=re1.exec(text))!==null){
      years.push(parseInt(m[1],10));
    }
    // detect year ranges: 2018-2023, 2018–2023
    const re2 = /((19|20)\d{2})\s*[–-]\s*((19|20)\d{2})/g;
    while((m=re2.exec(text))!==null){
      const a=parseInt(m[1],10), b=parseInt(m[3],10);
      if(b>=a) years.push(b-a+1);
    }
    return years;
  }

  // ---------- Simple entity extraction ----------
  // For MVP, extract tokens that look like skills: words with capitals, hyphenated tokens, common tech names
  const commonTechs = ["react","typescript","javascript","html","css","node","graphql","rest","aws","docker","kubernetes","jest","redux","webpack","sass","less","python","java","c#","sql","postgres","mongodb","ruby","php","angular","vue","next.js","nuxt","tailwind","git","jira","figma","accessibility","a11y"];
  function extractTokens(text){
    const tokens = new Set();
    // find words with letters/digits and punctuation inside
    text.split(/[\s,;(){}[\].<>:+/\\]+/).forEach(w=>{
      if(!w) return;
      const clean = w.replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g,'');
      if(!clean) return;
      if(clean.length<=1) return;
      tokens.add(clean);
      const lower = clean.toLowerCase();
      // include common techs when present as substring
      commonTechs.forEach(t=>{
        if(lower.includes(t)) tokens.add(t);
      });
    });
    return Array.from(tokens).map(t=>t.trim()).filter(Boolean);
  }

  // ---------- File parsing ----------
  async function readTextFile(file){
    const text = await file.text();
    return text;
  }

  async function readDocxFile(file){
    if(typeof mammoth !== 'undefined'){
      try{
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.extractRawText({arrayBuffer});
        return result.value;
      }catch(e){
        console.warn("mammoth failed",e);
      }
    }
    // fallback: try treating as binary text (not reliable)
    return await readTextFile(file);
  }

  async function readPdfFile(file){
    if(typeof pdfjsLib !== 'undefined' || typeof pdfjsLib === 'object'){
      try{
        const typed = new Uint8Array(await file.arrayBuffer());
        // pdf.js global may be pdfjsLib or pdfjs
        const lib = window['pdfjsLib'] || window['pdfjs'];
        lib.GlobalWorkerOptions.workerSrc = lib.GlobalWorkerOptions.workerSrc || 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
        const loading = await lib.getDocument({data:typed}).promise;
        let text = '';
        for(let i=1;i<=loading.numPages;i++){
          const page = await loading.getPage(i);
          const content = await page.getTextContent();
          const pageText = content.items.map(it=>it.str).join(' ');
          text += '\\n' + pageText;
        }
        return text;
      }catch(e){
        console.warn("pdf.js failed",e);
      }
    }
    // fallback
    return await readTextFile(file);
  }

  async function extractTextFromFile(file){
    const name = file.name.toLowerCase();
    if(name.endsWith('.pdf')) return await readPdfFile(file);
    if(name.endsWith('.docx') || name.endsWith('.doc')) return await readDocxFile(file);
    // treat everything else as text
    return await readTextFile(file);
  }

  // ---------- Main analysis ----------
  const resumeDrop = document.getElementById('resumeDrop');
  const resumeFileInput = document.getElementById('resumeFile');
  const resumeMeta = document.getElementById('resumeMeta');
  const resumePreview = document.getElementById('resumePreview');

  const jdText = document.getElementById('jdText');
  const jdSelectBtn = document.getElementById('jdSelectBtn');
  const jdFileInput = document.getElementById('jdFile');
  const jdMeta = document.getElementById('jdMeta');
  const jdPreview = document.getElementById('jdPreview');

  const analyzeBtn = document.getElementById('analyzeBtn');
  const exportBtn = document.getElementById('exportBtn');

  const scoreBadge = document.getElementById('scoreBadge');
  const scoreLabel = document.getElementById('scoreLabel');
  const progressFill = document.getElementById('progressFill');
  const skillCount = document.getElementById('skillCount');
  const keywordCount = document.getElementById('keywordCount');
  const matchedSkillsDiv = document.getElementById('matchedSkills');
  const missingSkillsDiv = document.getElementById('missingSkills');
  const recommendationsDiv = document.getElementById('recommendations');
  const experienceSummary = document.getElementById('experienceSummary');

  const modeSelect = document.getElementById('mode');

  let resumeText = '';
  let resumeFileMeta = null;
  let jdFileMeta = null;

  // handle resume drop/select
  resumeDrop.addEventListener('click', ()=> resumeFileInput.click());
  resumeSelectBtn.addEventListener('click', ()=> resumeFileInput.click());

  ['dragenter','dragover'].forEach(e=>{
    resumeDrop.addEventListener(e, ev=>{ev.preventDefault();resumeDrop.classList.add('dragover')});
  });
  ['dragleave','drop'].forEach(e=>{
    resumeDrop.addEventListener(e, ev=>{
      ev.preventDefault();
      resumeDrop.classList.remove('dragover');
    });
  });

  resumeDrop.addEventListener('drop', async (ev)=>{
    const file = ev.dataTransfer.files[0];
    if(file) await handleResumeFile(file);
  });

  resumeFileInput.addEventListener('change', async (ev)=>{
    const file = ev.target.files[0];
    if(file) await handleResumeFile(file);
  });

  async function handleResumeFile(file){
    resumeFileMeta = file;
    resumeMeta.textContent = `${file.name} — ${fmtBytes(file.size)} — ${file.type || 'unknown'}`;
    resumeText = await extractTextFromFile(file);
    resumePreview.textContent = normalizeText(resumeText) || "Unable to extract text from file.";
    // word count
    const wc = (resumeText||'').split(/\s+/).filter(Boolean).length;
    resumeMeta.textContent += ` — ${wc} words`;
    // enable analyze
  }

  // JD upload
  jdSelectBtn.addEventListener('click', ()=> jdFileInput.click());
  jdFileInput.addEventListener('change', async (ev)=>{
    const file = ev.target.files[0];
    if(!file) return;
    jdFileMeta = file;
    jdMeta.textContent = `${file.name} — ${fmtBytes(file.size)} — ${file.type || 'unknown'}`;
    const txt = await extractTextFromFile(file);
    jdText.value = normalizeText(txt);
    jdPreview.textContent = normalizeText(txt);
    const wc = (txt||'').split(/\s+/).filter(Boolean).length;
    jdMeta.textContent += ` — ${wc} words`;
  });

  // allow paste into JD area to auto-update preview
  jdText.addEventListener('input', ()=> {
    jdPreview.textContent = jdText.value || 'No job description';
  });

  // click highlight handler (event delegation)
  function onHighlightClick(ev){
    const target = ev.target.closest('.highlight, .missing');
    if(!target) return;
    const info = target.dataset && target.dataset.info;
    if(info){
      alert(info);
    }
  }
  resumePreview.addEventListener('click', onHighlightClick);
  jdPreview.addEventListener('click', onHighlightClick);

  // main analyze logic
  analyzeBtn.addEventListener('click', runAnalysis);

  function computeScore({matchedSkills, totalSkills, matchedKeywords, totalKeywords, experienceScore}){
    // weights: skills 50%, keywords 30%, experience 20%
    const skillsPart = totalSkills? (matchedSkills/totalSkills): 0;
    const keywordsPart = totalKeywords? (matchedKeywords/totalKeywords): 0;
    const score = Math.round(
      100 * (0.5*skillsPart + 0.3*keywordsPart + 0.2*(experienceScore/100))
    );
    return {score, skillsPart, keywordsPart};
  }

  function classifyBadge(score){
    if(score>=75) return {cls:'good', label:'Great fit', color: 'var(--good)'};
    if(score>=45) return {cls:'warn', label:'Partial fit', color: 'var(--warn)'};
    return {cls:'bad', label:'Low fit', color: 'var(--bad)'};
  }

  function highlightText(containerEl, text, tokens, mode){
    // naive approach: iterate tokens and wrap first N occurrences
    // create HTML with simple token highlights
    let out = escapeHtml(text);
    // order tokens by length desc to avoid partial overlaps
    tokens = [...new Set(tokens)].sort((a,b)=>b.length-a.length);
    for(const tok of tokens){
      if(!tok) continue;
      const re = new RegExp('\\b' + escapeRegex(tok) + '\\b', 'ig');
      out = out.replace(re, (match) => `<span class="highlight" data-info="Matched token: ${escapeHtml(match)}">${match}</span>`);
    }
    containerEl.innerHTML = out;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m]));
  }

  async function runAnalysis(){
    const jd = normalizeText(jdText.value || '');
    if(!jd){
      alert('Please paste or upload a job description first.');
      return;
    }
    if(!resumeText){
      alert('Please upload a resume first.');
      return;
    }

    // token extraction
    const jdTokens = extractTokens(jd).map(t=>t.toLowerCase());
    const resumeTokens = extractTokens(resumeText).map(t=>t.toLowerCase());

    // define "skills/keywords" as tokens present in JD that are likely techs / skills
    // Use the intersection with commonTechs or tokens longer than 2 chars
    const jdUnique = Array.from(new Set(jdTokens));
    // heuristics: consider tokens that appear in JD and look like skills (commonTechs or letters-only)
    const candidateSkills = jdUnique.filter(t=>{
      if(commonTechs.includes(t)) return true;
      if(/^[a-z0-9\-\+#\.]+$/.test(t) && t.length>1) return true;
      return false;
    });

    // matching mode
    const mode = modeSelect.value; // strict | lenient

    const matchedSkills = [];
    const missingSkills = [];
    const matchedKeywordsSet = new Set();

    for(const skill of candidateSkills){
      let matched = false;
      for(const rTok of resumeTokens){
        if(mode==='strict'){
          if(rTok===skill) matched=true;
        } else {
          if(rTok===skill || fuzzyMatch(rTok,skill)) matched=true;
        }
        if(matched){
          matchedKeywordsSet.add(skill);
          break;
        }
      }
      if(matched) matchedSkills.push(skill);
      else missingSkills.push(skill);
    }

    // keyword matching (broader): pick top N tokens from JD (frequency)
    const jdWords = jd.toLowerCase().split(/\W+/).filter(Boolean);
    const freq = {};
    for(const w of jdWords) freq[w]=(freq[w]||0)+1;
    const sorted = Object.keys(freq).sort((a,b)=>freq[b]-freq[a]);
    const topKeywords = sorted.slice(0,30).filter(w=>w.length>2);

    let matchedKeywords = 0;
    for(const kw of topKeywords){
      let present=false;
      for(const rt of resumeTokens){
        if(mode==='strict'){
          if(rt===kw) present=true;
        } else {
          if(rt===kw || fuzzyMatch(rt,kw)) present=true;
        }
        if(present) break;
      }
      if(present) matchedKeywords++;
    }

    // years-of-experience detection
    const jdYears = detectYears(jd);
    const resumeYears = detectYears(resumeText);
    // derive numeric experienceScore: if JD requests >=X years, see if resume matches
    let experienceScore = 50; // neutral
    if(jdYears.length>0){
      const jdMax = Math.max(...jdYears);
      const resumeMax = resumeYears.length>0 ? Math.max(...resumeYears) : 0;
      if(resumeMax>=jdMax) experienceScore = 100;
      else experienceScore = Math.max(0, Math.round((resumeMax/jdMax)*100));
    } else {
      // if no explicit years in JD, but resume mentions many years -> give some points
      const resumeMax = resumeYears.length>0 ? Math.max(...resumeYears) : 0;
      experienceScore = resumeMax>=3 ? 80 : (resumeMax>0?60:40);
    }

    // compute score
    const {score, skillsPart, keywordsPart} = computeScore({
      matchedSkills: matchedSkills.length,
      totalSkills: Math.max(candidateSkills.length,1),
      matchedKeywords,
      totalKeywords: Math.max(topKeywords.length,1),
      experienceScore
    });

    // set UI
    const badgeInfo = classifyBadge(score);
    scoreBadge.textContent = score + '%';
    scoreBadge.className = 'badge ' + badgeInfo.cls;
    scoreLabel.textContent = `${badgeInfo.label} — ${Math.round(100*(0.5*skillsPart + 0.3*keywordsPart + 0.2*(experienceScore/100)))}% (composed)`;
    progressFill.style.width = score + '%';
    // progressFill color variant:
    progressFill.style.background = score>=75 ? 'linear-gradient(90deg,var(--good), #1aa84f)' : (score>=45 ? 'linear-gradient(90deg,var(--warn), #ff9d2b)' : 'linear-gradient(90deg,var(--bad), #ff2f5b)');

    skillCount.textContent = `Skills: ${matchedSkills.length}/${candidateSkills.length}`;
    keywordCount.textContent = `Keywords: ${matchedKeywords}/${topKeywords.length}`;

    matchedSkillsDiv.innerHTML = matchedSkills.length? matchedSkills.map(s=>'<div class="chip" style="margin:4px;display:inline-block">'+escapeHtml(s)+'</div>').join(' ') : '<span class="muted">No matched skills found</span>';
    missingSkillsDiv.innerHTML = missingSkills.length? missingSkills.map(s=>'<div class="chip" style="margin:4px;display:inline-block">'+escapeHtml(s)+'</div>').join(' ') : '<span class="muted">No missing skills detected</span>';

    // recommendations: suggest adding missing skills into summary bullets
    const recs = [];
    if(missingSkills.length){
      recs.push(`Add or emphasize these skills in your resume: ${missingSkills.slice(0,10).join(', ')}.`);
    } else {
      recs.push('Resume already contains most of the explicit JD skills.');
    }
    if(score<60){
      recs.push('Consider adding measurable achievements and years of experience aligned with the JD.');
    } else {
      recs.push('Good match — refine phrasing and include keywords exactly as written in JD for applicant tracking systems (ATS).');
    }
    recommendationsDiv.textContent = recs.join(' ');

    // experience summary
    experienceSummary.textContent = resumeYears.length? `${Math.max(...resumeYears)} yrs (detected)` : 'No years found';

    // highlight preview: highlight matched tokens in both JD and Resume
    // We'll highlight matchedSkills in both and highlight missing as "missing" label in resume preview (so user sees which to add)
    // JD preview: highlight candidate skills
    const jdHtml = generateHighlightedHtml(jd, candidateSkills, matchedSkills);
    jdPreview.innerHTML = jdHtml;

    // Resume preview: highlight matched skills and mark missing as suggestion place (missing spans not present in resume but visualized separately)
    const resumeHtml = generateHighlightedHtml(resumeText, matchedSkills, []);
    resumePreview.innerHTML = resumeHtml;

    // attach data-info tooltips to matched tokens
    attachInfoSpans(jdPreview, 'JD');
    attachInfoSpans(resumePreview, 'Resume');

    // done
  }

  function generateHighlightedHtml(text, tokensToHighlight, secondaryTokens){
    // tokensToHighlight: highlight these tokens. secondaryTokens: tokens that are matched (we can distinguish by class)
    // tokens represented as lower-case strings
    let out = escapeHtml(text);
    const tokens = Array.from(new Set(tokensToHighlight)).sort((a,b)=>b.length-a.length);
    for(const tok of tokens){
      if(!tok) continue;
      const className = (secondaryTokens && secondaryTokens.includes(tok)) ? 'highlight' : 'highlight';
      const re = new RegExp('\\b' + escapeRegex(tok) + '\\b', 'ig');
      out = out.replace(re, (match) => `<span class="${className}" data-token="${escapeHtml(tok)}" data-info="Matched: ${escapeHtml(match)}">${match}</span>`);
    }
    return out;
  }

  function attachInfoSpans(container, sourceLabel){
    container.querySelectorAll('span[data-token]').forEach(sp=>{
      const token = sp.dataset.token;
      sp.dataset.info = `${sourceLabel} — token: "${token}" (click for details)`;
      sp.tabIndex = 0;
      sp.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Enter' || ev.key === ' ') alert(sp.dataset.info);
      });
      sp.addEventListener('click', ()=>{
        alert(sp.dataset.info);
      });
    });
  }

  // Export feedback: create simple TXT summary
  exportBtn.addEventListener('click', ()=>{
    const jd = normalizeText(jdText.value||'');
    if(!jd || !resumeText){
      alert('Please load both resume and job description first.');
      return;
    }
    const summary = [];
    summary.push('Resume ↔ Job Description Analysis — Summary');
    summary.push('Date: ' + new Date().toLocaleString());
    if(resumeFileMeta) summary.push(`Resume file: ${resumeFileMeta.name} — ${fmtBytes(resumeFileMeta.size)}`);
    if(jdFileMeta) summary.push(`JD file: ${jdFileMeta.name} — ${fmtBytes(jdFileMeta.size)}`);
    summary.push('');
    summary.push('Match score: ' + (scoreBadge.textContent || '—'));
    summary.push('');
    summary.push('Top matched skills:');
    summary.push(Array.from(document.querySelectorAll('#matchedSkills .chip')).map(c=>c.textContent).join(', ') || 'None');
    summary.push('');
    summary.push('Missing skills (suggested):');
    summary.push(Array.from(document.querySelectorAll('#missingSkills .chip')).map(c=>c.textContent).join(', ') || 'None');
    summary.push('');
    summary.push('Recommendations:');
    summary.push(recommendationsDiv.textContent || '—');
    const blob = new Blob([summary.join('\\n')], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'resume_jd_feedback.txt';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // small keyboard accessibility: allow dropzone activation via keyboard
  resumeDrop.addEventListener('keydown', (ev)=>{
    if(ev.key === 'Enter' || ev.key === ' ') resumeFileInput.click();
  });

  // small helper: if user pastes resume text directly (optional)
  // Add a global paste handler: if user Ctrl+V when focus on body and clipboard contains text and no files loaded, offer to use it as resume.
  document.addEventListener('paste', async (ev)=>{
    const active = document.activeElement;
    if(active === jdText) return; // ignore when pasting into JD
    const items = ev.clipboardData && ev.clipboardData.items;
    if(items){
      for(const it of items){
        if(it.kind === 'file' && it.type){
          const file = it.getAsFile();
          if(file) await handleResumeFile(file);
          return;
        }
      }
      // fallback: text
      const txt = ev.clipboardData.getData('text');
      if(txt && !resumeText){
        if(confirm('Use pasted text as resume content?')){
          resumeText = txt;
          resumePreview.textContent = normalizeText(txt);
          resumeMeta.textContent = 'Pasted text — approx ' + ((txt||'').split(/\s+/).filter(Boolean).length) + ' words';
        }
      }
    }
  });

  // initialize small sample content for quick demo
  (function seedDemo(){
    jdText.value = `Frontend Engineer — React & TypeScript
Responsibilities:
- Build and maintain web applications using React and TypeScript.
- Work with REST APIs and GraphQL.
- 3+ years experience in front-end development.
Must-have skills: React, TypeScript, HTML5, CSS3, responsive design, REST APIs.
Nice-to-have: GraphQL, Jest, accessibility (WCAG).`;
    jdPreview.textContent = jdText.value;
    // resume sample (simple)
    resumeText = `Senior Frontend Engineer with 4 years experience building React applications using TypeScript, HTML5 and CSS3. Built REST APIs integrations and worked with GraphQL. Familiar with Jest and accessibility best practices.`;
    resumePreview.textContent = resumeText;
    resumeMeta.textContent = 'Demo text — pasted sample';
    jdMeta.textContent = 'Demo JD text';
  })();

  </script>
</body>
</html>
